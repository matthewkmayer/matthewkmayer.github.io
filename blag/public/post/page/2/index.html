<!DOCTYPE html>
<html lang="en-us">
    <head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">

		<title>
				Posts &middot; Matthew Mayer&#39;s tech blog
		</title>

		
  		<link rel="stylesheet" href="/blag/public/css/style.css">
		<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Libre+Baskerville:400,400i,700">
		
		<link rel="icon" type="image/png" sizes="32x32" href="/blag/public/images/favicon-32x32.png">
		<link rel="icon" type="image/png" sizes="16x16" href="/blag/public/images/favicon-16x16.png">
		<link rel="apple-touch-icon" sizes="180x180" href="/blag/public/images/apple-touch-icon.png">

		
		<link href="/blag/public/post/index.xml" rel="alternate" type="application/rss+xml" title="Matthew Mayer&#39;s tech blog" />
	</head>

    <body>
        		<nav class="nav">
			<div class="nav-container">
				<a href="/blag/public/">
					<h2 class="nav-title">Matthew Mayer&#39;s tech blog</h2>
				</a>
				<ul>
    <li><a href="/blag/public/about">About</a></li>
    <li><a href="/blag/public/">Posts</a></li>
</ul>
			</div>
		</nav>

        

<main>
	<div class="catalogue">
		
			<a href="https://matthewkmayer.github.io/blag/public/post/rusoto-2017-in-review/" class="catalogue-item">
    <div>
        <time datetime="2017-12-31 21:28:53 -0700 -0700" class="catalogue-time">December 31, 2017</time>
        <h1 class="catalogue-title">Rusoto: 2017 in review</h1>
        <div class="catalogue-line"></div>

        <p>
            Rusoto, an unofficial SDK for Amazon Web Services, had a wonderful year! We made great strides in improving functionality, increasing the number of services covered and making various ergonomic changes.
Improved functionality  Added all publicly available AWS regions Custom endpoint support HTTP connection pools for connecting to services S3 supports streaming responses: no more loading the entire file to download into a Vector  More supported services A non-exhaustive list:
        </p>
    </div>
</a>

		
			<a href="https://matthewkmayer.github.io/blag/public/post/tdd-with-rust/" class="catalogue-item">
    <div>
        <time datetime="2017-10-19 21:28:53 -0700 PDT" class="catalogue-time">October 19, 2017</time>
        <h1 class="catalogue-title">Test driven development with Rust</h1>
        <div class="catalogue-line"></div>

        <p>
            Test Driven Development (TDD) encourages better software design. When the desired behavior is known and expressible, it&rsquo;s highly effective to make modular and easily tested code.
Let&rsquo;s take a look at using TDD with Rust, using release-party as an example.
What we&rsquo;re changing Release-party is a command line tool I made for my day job. We&rsquo;ve got a fair amount of repositories on GitHub: one for each microservice. Our deployments are automated through TravisCI: the master branch is deployed to our testing environment and the release branch is deployed to production.
        </p>
    </div>
</a>

		
			<a href="https://matthewkmayer.github.io/blag/public/post/software-dev-force-multipliers/" class="catalogue-item">
    <div>
        <time datetime="2017-09-20 21:28:53 -0700 PDT" class="catalogue-time">September 20, 2017</time>
        <h1 class="catalogue-title">Software development force multipliers</h1>
        <div class="catalogue-line"></div>

        <p>
            While a software enginerd/pixie wrangler at heart, I&rsquo;ve discovered the stereotypical developer path of grabbing a ticket from Jira, working on it, shoving the results to QA and repeat isn&rsquo;t for me. The biggest reason is how this leaves a tremendous amount of efficiency on the table. This inefficient approach is difficult to reconcile with empathy for the customer buying and using the product.
My code writing speed has peaked: I can&rsquo;t write code any faster.
        </p>
    </div>
</a>

		
			<a href="https://matthewkmayer.github.io/blag/public/post/rustconf-2017-recap/" class="catalogue-item">
    <div>
        <time datetime="2017-08-20 21:28:53 -0700 PDT" class="catalogue-time">August 20, 2017</time>
        <h1 class="catalogue-title">RustConf 2017 recap</h1>
        <div class="catalogue-line"></div>

        <p>
            My recap of RustConf 2017 in Portland, Oregon. Or: how I avoided hotel surge pricing during the eclipse weekend!
RustConf the second I&rsquo;ve been told the first conference for community or technology is the best. I&rsquo;m happy to report I don&rsquo;t believe it applies in this case! The first RustConf set a tone of possibility and potentials whereas RustConf 2017 focused more on the progress made in the language, ecosystem and community.
        </p>
    </div>
</a>

		
			<a href="https://matthewkmayer.github.io/blag/public/post/rusoto-codegen-part-three/" class="catalogue-item">
    <div>
        <time datetime="2017-07-11 21:28:53 -0700 PDT" class="catalogue-time">July 11, 2017</time>
        <h1 class="catalogue-title">Rusoto codegen, part three</h1>
        <div class="catalogue-line"></div>

        <p>
            This is part three of Rusoto code generation. The first two parts went over how code inside a crate is generated. In this post, we&rsquo;ll take a look at how we make the crate for an AWS service.
Parts one and two recap In the previous two posts, we followed code generation from the Simple Queue Service (SQS) botocore service definition to Rust code. We glossed over where the generated code went in order to concentrate on the generation itself.
        </p>
    </div>
</a>

		
			<a href="https://matthewkmayer.github.io/blag/public/post/rusoto-codegen-part-two/" class="catalogue-item">
    <div>
        <time datetime="2017-06-16 21:28:53 -0700 PDT" class="catalogue-time">June 16, 2017</time>
        <h1 class="catalogue-title">Rusoto codegen, part two</h1>
        <div class="catalogue-line"></div>

        <p>
            In the previous post we took a quick tour of the major pieces of Rusoto code generation. In this post we&rsquo;ll get deeper into code generation for the Simple Queue Service.
Picking up from part one Part one described a few parts of Rusoto codegen:
 Finding which services to generate Making the service&rsquo;s crate Generating the service and placing it inside its crate rustfmt the generated code to make it look pretty  Step three is where this post will concentrate.
        </p>
    </div>
</a>

		
			<a href="https://matthewkmayer.github.io/blag/public/post/rusoto-codegen/" class="catalogue-item">
    <div>
        <time datetime="2017-06-09 21:28:53 -0700 PDT" class="catalogue-time">June 9, 2017</time>
        <h1 class="catalogue-title">Rusoto codegen</h1>
        <div class="catalogue-line"></div>

        <p>
            Writing a software development kit (SDK) is a challenge. Especially when the target has a tremendous number of services, endpoints and different styles of interacting, such as REST, querystring and &ldquo;other.&rdquo; Rusoto uses the botocore service definitions to create Rust code to interact with Amazon Web Services. Let&rsquo;s dive into how it&rsquo;s done!
Using Simple Queue Service as an example To make this post clearer, we&rsquo;ll follow the Simple Queue Service (SQS) from botocore service definition to the rusoto_sqs crate.
        </p>
    </div>
</a>

		
			<a href="https://matthewkmayer.github.io/blag/public/post/rusoto-rds-mk2/" class="catalogue-item">
    <div>
        <time datetime="2017-05-23 21:28:53 -0700 PDT" class="catalogue-time">May 23, 2017</time>
        <h1 class="catalogue-title">Rusoto RDS walkthrough, mk 2</h1>
        <div class="catalogue-line"></div>

        <p>
            Since the publication of Rusoto RDS walkthrough, a new version of Rusoto has been released: 0.25.0. This includes some breaking changes so let&rsquo;s work through those. We&rsquo;ll also be cleaning up some of the rougher edges in the previous walkthrough.
rusoto-rds-mk2 The previous project&rsquo;s source code is on github. We&rsquo;ll be making a new project based off that one. You can see the final product in rusoto-rds-mk2 folder.
Cargo.toml changes required for Rusoto 0.
        </p>
    </div>
</a>

		
			<a href="https://matthewkmayer.github.io/blag/public/post/rusoto-rds-walkthrough/" class="catalogue-item">
    <div>
        <time datetime="2017-05-14 21:28:53 -0700 PDT" class="catalogue-time">May 14, 2017</time>
        <h1 class="catalogue-title">Rusoto RDS walkthrough</h1>
        <div class="catalogue-line"></div>

        <p>
            Let&rsquo;s tie some great Rust crates together! In this walkthrough, we&rsquo;ll use Rusoto to create a Postgres RDS database instance, Rocket.rs to make a web server and Diesel to talk to the database on AWS to make a proof of concept hit counter.
Walkthrough overview There are two projects in this walkthrough. First is rusoto-rds. This creates the Amazon Web Services (AWS) Relational Database Service (RDS) instance and should be run first.
        </p>
    </div>
</a>

		
	</div>
	
	<div class="pagination">
		
			<a href="/blag/public/post/" class="left arrow">&#8592;</a>
		
		
	
		<span>2</span>
	</div>
</main>


        		<footer>
			<span>
			&copy; <time datetime="2019-05-25 19:37:37.053239 -0700 PDT m=&#43;0.259224783">2019</time> . Made with <a href='https://gohugo.io'>Hugo</a> using the <a href='https://github.com/EmielH/tale-hugo/'>Tale</a> theme.
			</span>
		</footer>

    </body>
</html>
